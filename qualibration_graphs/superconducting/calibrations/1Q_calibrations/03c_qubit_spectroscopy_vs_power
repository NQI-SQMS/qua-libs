# %% {Imports}
import matplotlib.pyplot as plt
import numpy as np
import xarray as xr
from dataclasses import asdict

from qm.qua import *

from qualang_tools.loops import from_array
from qualang_tools.multi_user import qm_session
from qualang_tools.results import progress_counter
from qualang_tools.units import unit

from qualibrate import QualibrationNode
from quam_config import Quam

from quam_builder.tools.power_tools import calculate_voltage_scaling_factor

from calibration_utils.qubit_spectroscopy_vs_power import (
    Parameters,
    process_raw_dataset,
    fit_raw_data,
    log_fitted_results,
    plot_raw_data_with_fit,
)

from qualibration_libs.parameters import get_qubits
from qualibration_libs.data import XarrayDataFetcher
from qualibration_libs.core import tracked_updates


# %% {Node initialisation}
description = """
        QUBIT SPECTROSCOPY VS DRIVE POWER
This sequence involves probing the qubit transition by applying an XY drive while sweeping the drive power and
intermediate frequency around the expected qubit transition for all active qubits.
The qubit response is measured via the readout resonator, and the demodulated I/Q signals are post-processed to extract
the qubit spectroscopy signal as a function of frequency and drive power.

The resulting 2D spectroscopy map is analyzed to identify the qubit transition frequency, assess power broadening
and saturation effects, and select an appropriate drive power for subsequent calibrations.
A rough estimate of the qubit frequency at the selected drive power is extracted and used to update the qubit state.

Prerequisites:
    - Having calibrated the IQ mixer/Octave connected to the XY control line (node 01a_mixer_calibration.py).
    - Having calibrated the readout chain, including time of flight, offsets, and gains (node 01a_time_of_flight.py).
    - Having calibrated the readout resonator frequency (node 02_resonator_spectroscopy.py).
    - Having initialized the QUAM state parameters for the qubit XY pulse frequency span, power sweep range,
      and pulse duration.
    - Having specified the desired flux point if relevant (qubit.z.flux_point).

State update:
    - The qubit transition frequency at the selected power:
      qubit.xy.f_01 & qubit.xy.RF_frequency
    - The selected spectroscopy drive power: qubit.xy.spectroscopy_power
"""


node = QualibrationNode[Parameters, Quam](
    name="03c_qubit_spectroscopy_vs_power",
    description=description,
    parameters=Parameters(),
)


@node.run_action(skip_if=node.modes.external)
def custom_param(node: QualibrationNode[Parameters, Quam]):
    node.parameters.qubits = ["q1"]
    node.parameters.frequency_span_in_mhz = 200
    node.parameters.frequency_step_in_mhz = 1
    node.parameters.num_power_points = 10
    node.parameters.num_shots = 100
    node.parameters.min_power_dbm = -80
    node.parameters.max_power_dbm = 0
    node.parameters.operation = "saturation"
    node.parameters.operation_len_in_ns = 200_000
    node.parameters.max_amplitude_opx = 0.4
    node.parameters.min_peak_fraction = 0.1
    node.parameters.baseline_iq_abs_v = 0.006
    node.parameters.max_iq_abs_v = 0.011


node.machine = Quam.load()


# %% {Create_QUA_program}
@node.run_action(skip_if=node.parameters.load_data_id is not None)
def create_qua_program(node: QualibrationNode[Parameters, Quam]):
    u = unit(coerce_to_integer=True)

    qubits = get_qubits(node)
    num_qubits = len(qubits)
    n_avg = node.parameters.num_shots
    node.namespace["qubits"] = qubits

    node.namespace["tracked_qubits"] = []
    for qubit in qubits:
        with tracked_updates(qubit.xy, auto_revert=False) as xy:
            xy.set_output_power(
                power_in_dbm=node.parameters.max_power_dbm,
                max_amplitude=node.parameters.max_amplitude_opx,
                operation=node.parameters.operation,
            )
            node.namespace["tracked_qubits"].append(xy)

    span = node.parameters.frequency_span_in_mhz * u.MHz
    step = node.parameters.frequency_step_in_mhz * u.MHz
    dfs = np.arange(-span / 2, +span / 2, step)

    powers_dbm = np.linspace(
        node.parameters.min_power_dbm,
        node.parameters.max_power_dbm,
        node.parameters.num_power_points,
    )

    amps = np.geomspace(node.parameters.min_amplitude_opx, 1.0, node.parameters.num_power_points)

    node.namespace["powers_dbm"] = powers_dbm
    node.namespace["amps"] = amps

    node.namespace["sweep_axes"] = {
        "qubit": xr.DataArray(qubits.get_names(), dims="qubit"),
        "detuning": xr.DataArray(dfs, dims="detuning", attrs={"units": "Hz"}),
        "power": xr.DataArray(powers_dbm, dims="power", attrs={"units": "dBm"}),
    }

    with program() as node.namespace["qua_program"]:
        I, I_st, Q, Q_st, n, n_st = node.machine.declare_qua_variables()

        df = declare(int)
        a = declare(fixed)

        for multiplexed_qubits in qubits.batch():
            for qubit in multiplexed_qubits.values():
                node.machine.initialize_qpu(target=qubit)
            align()

            with for_(n, 0, n < n_avg, n + 1):
                save(n, n_st)

                # OUTER LOOP: frequency
                with for_(*from_array(df, dfs)):
                    for qubit in multiplexed_qubits.values():
                        qubit.xy.update_frequency(
                            df + qubit.xy.intermediate_frequency
                        )

                    # INNER LOOP: amplitude (power)
                    with for_each_(a, amps):
                        for qubit in multiplexed_qubits.values():
                            duration = (
                                node.parameters.operation_len_in_ns
                                if node.parameters.operation_len_in_ns is not None
                                else qubit.xy.operations[
                                    node.parameters.operation
                                ].length
                            )
                            qubit.xy.play(
                                node.parameters.operation,
                                duration=duration // 4,
                                amplitude_scale=a,
                            )

                        align()

                        for qi, qubit in multiplexed_qubits.items():
                            qubit.resonator.measure(
                                "readout",
                                qua_vars=(I[qi], Q[qi]),
                            )
                            qubit.resonator.wait(
                                node.machine.depletion_time * u.ns
                            )
                            save(I[qi], I_st[qi])
                            save(Q[qi], Q_st[qi])

                        align()

        with stream_processing():
            n_st.save("n")
            for i in range(num_qubits):
                (
                    I_st[i]
                    .buffer(len(amps))   # INNER loop (power)
                    .buffer(len(dfs))    # OUTER loop (detuning)
                    .average()
                    .save(f"I{i+1}")
                )
                (
                    Q_st[i]
                    .buffer(len(amps))
                    .buffer(len(dfs))
                    .average()
                    .save(f"Q{i+1}")
                )



# %% {Execute}
@node.run_action(skip_if=node.parameters.load_data_id is not None or node.parameters.simulate)
def execute_qua_program(node: QualibrationNode[Parameters, Quam]):
    qmm = node.machine.connect()
    config = node.machine.generate_config()

    with qm_session(qmm, config, timeout=node.parameters.timeout) as qm:
        node.namespace["job"] = job = qm.execute(node.namespace["qua_program"])
        data_fetcher = XarrayDataFetcher(job, node.namespace["sweep_axes"])

        for dataset in data_fetcher:
            progress_counter(
                data_fetcher.get("n", 0),
                node.parameters.num_shots,
                start_time=data_fetcher.t_start,
            )

        node.log(job.execution_report())
    
    node.results["ds_raw"] = dataset

# %% {Analyse_data}
@node.run_action(skip_if=node.parameters.simulate)
def analyse_data(node: QualibrationNode[Parameters, Quam]):
    node.results["ds_raw"] = process_raw_dataset(node.results["ds_raw"], node)
    ds_fit, fit_results = fit_raw_data(node.results["ds_raw"], node)

    node.results["ds_fit"] = ds_fit
    node.results["fit_results"] = {k: asdict(v) for k, v in fit_results.items()}

    log_fitted_results(fit_results, log_callable=node.log)

    node.outcomes = {
        q: ("successful" if r.success else "failed")
        for q, r in fit_results.items()
    }


# %% {Plot_data}
@node.run_action(skip_if=node.parameters.simulate)
def plot_data(node: QualibrationNode[Parameters, Quam]):
    fig = plot_raw_data_with_fit(
        node.results["ds_raw"],
        node.namespace["qubits"],
        node.results["ds_fit"],
    )
    plt.show()
    node.results["figures"] = {"spectroscopy_vs_power": fig}


# %% {Update_state}
@node.run_action(skip_if=node.parameters.simulate)
def update_state(node: QualibrationNode[Parameters, Quam]):
    """
    Update qubit state based on spectroscopy vs power analysis:
      - XY Octave output power
      - Saturation amplitude
      - Qubit frequency
    """

    ds = node.results["ds_fit"]
    qubits = node.namespace["qubits"]

    # ------------------------------------------------------------------
    # Revert temporary sweep changes
    # ------------------------------------------------------------------
    for tracked_qubit in node.namespace.get("tracked_qubits", []):
        tracked_qubit.revert_changes()

    # ------------------------------------------------------------------
    # Apply calibrated values
    # ------------------------------------------------------------------
    with node.record_state_updates():
        for qubit in qubits:
            qname = qubit.name
            ds_q = ds.sel(qubit=qname)

            # -----------------------------
            # Selected power (dBm)
            # -----------------------------
            selected_power_dbm = float(ds_q.selected_power)
            
            # -----------------------------
            # Selected OPX amplitude
            # -----------------------------
            # selected_amp = float(ds_q.selected_amplitude_opx)

            # -----------------------------
            # Selected qubit frequency (Hz)
            # -----------------------------
            selected_freq = float(ds_q.rough_qubit_frequency)

            # -----------------------------
            # Update XY output power
            # -----------------------------
            new_power_settings = qubit.xy.set_output_power(
                power_in_dbm=selected_power_dbm,
                max_amplitude=node.parameters.max_amplitude_opx,
                operation=node.parameters.operation,
            )

            if node.parameters.operation != "saturation":
                new_power_settings = qubit.xy.set_output_power(
                    power_in_dbm=selected_power_dbm,
                    max_amplitude=node.parameters.max_amplitude_opx,
                    operation="x180",
                )

            # -----------------------------
            # Update qubit frequency
            # -----------------------------
            qubit.xy.RF_frequency = selected_freq
            qubit.f_01 = selected_freq

            node.log(
                f"[{qname}] Updated state:\n"
                f"  XY power          = {selected_power_dbm:.2f} dBm\n"
                f"  Octave gain       = {new_power_settings['gain']:.2f} dBm\n"
                f"  Pulse amplitude   = {new_power_settings['amplitude']:.2f} dBm\n"
                f"  Qubit frequency   = {selected_freq / 1e9:.6f} GHz"
            )



# %% {Save_results}
@node.run_action()
def save_results(node: QualibrationNode[Parameters, Quam]):
    node.save()
